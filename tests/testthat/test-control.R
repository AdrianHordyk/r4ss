context("Read and write SS control file r4ss functions")

# Note: these tests are not very extensive. They only check that a list is
# successfully created. 

# read/write in a temporary dir so that the state is not disrupted if tests 
# exit early.
tmp_path <- file.path(tempdir(check = TRUE), "test-control")
dir.create(tmp_path, showWarnings = FALSE)
example_path <- system.file("extdata", package = "r4ss")
file.copy(example_path, tmp_path, recursive = TRUE)
#clean up
on.exit(unlink(tmp_path, recursive = TRUE))

# paths to the model files
sim_3.30.13 <- file.path(tmp_path, "extdata", "simple_3.30.13")
sim_3.24 <- file.path(tmp_path, "extdata", "simple_3.24")

test_that("SS_readctl and SS_writectl works for 3.30.13", {
  # read data file b/c necessary input to read control
  dat_3.30.13 <- SS_readdat(file.path(sim_3.30.13, "simple_data.ss"),
                            verbose = FALSE)
  # read the control file so that test can run on it
  ctl_3.30.13 <- SS_readctl(
    file.path(sim_3.30.13, "simple_control.ss"),
    verbose = FALSE,
    use_datlist = TRUE,
    datlist = dat_3.30.13)
  expect_type(ctl_3.30.13, "list")
  #check write control
  if(file.exists(file.path(sim_3.30.13,"testctl.ss"))){
    file.remove(file.path(sim_3.30.13,"testctl.ss"))
  }
  SS_writectl(ctllist = ctl_3.30.13,
              verbose = FALSE,
              overwrite = FALSE,
              outfile = file.path(sim_3.30.13,"testctl.ss"))
  expect_true(file.exists(file.path(sim_3.30.13,"testctl.ss")))
})
test_that("SS_readctl and SS_writectl works for 3.24", {
  # read data file b/c necessary input to read control
  dat_3.24 <- SS_readdat(file.path(sim_3.24, "simple.dat"),
                         verbose = FALSE, version = "3.24")
  # read the control file
  ctl_3.24 <- SS_readctl(file = file.path(sim_3.24, "simple.ctl"),
                         verbose = FALSE,
                         use_datlist = TRUE,
                         datlist = dat_3.24,
                         version = "3.24")
  expect_type(ctl_3.24, "list")
  #check write control
  if(file.exists(file.path(sim_3.24,"testctl.ss"))){
    file.remove(file.path(sim_3.24,"testctl.ss"))
  }
  SS_writectl(ctllist = ctl_3.24,
              verbose = FALSE,
              overwrite = TRUE,
              outfile = file.path(sim_3.24, "testctl.ss"))
  expect_true(file.exists(file.path(sim_3.24, "testctl.ss")))
})

test_that("SS_readctl and SS_writectl works for 3.30 files with timevarying MG parameters", {
  tv_folder <- file.path(example_path, "simple_variations", "time_varying")
  dat <- SS_readdat(file.path(tv_folder, "env_link.dat"), verbose = FALSE)
  # short parlines should be autogenerated in MG
  expect_warning(SS_readctl(file.path(tv_folder, "MG_env_dev_block_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat),
    "There are time varying MG parameters, and AUTOGEN for MG is 0")
  ctl_auto <- suppressWarnings(
                SS_readctl(file.path(tv_folder, "MG_env_dev_block_autogen.ctl"),
                           use_datlist = TRUE, datlist = dat,
                           verbose = FALSE)
              )
  # when autogeneration is on, the function should not try to read short parlines.
  expect_null(ctl_auto$MG_parms_tv)
  SS_writectl(ctllist = ctl_auto,
              verbose = FALSE,
              overwrite = TRUE,
              outfile = file.path(tmp_path, "ctl_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_auto.ss")))
  unlink(file.path(tmp_path, "ctl_auto.ss"))
  # no autogeneration of short MG par lines selected in ctl
  ctl_no_auto <- SS_readctl(file.path(tv_folder,
                                      "MG_env_dev_block_no_autogen.ctl"),
                            verbose = F, use_datlist = TRUE, datlist = dat)
  ctl_no_auto_ln <- readLines(file.path(tv_folder,
                                        "MG_env_dev_block_no_autogen.ctl"))
  ln1 <- grep("# timevary MG parameters", ctl_no_auto_ln)
  ln2 <- grep("# info on dev vectors created for MGparms are", ctl_no_auto_ln)
  nlns <- ln2 -ln1 - 2 # need to subtract header
  expect_equal(nrow(ctl_no_auto$MG_parms_tv), nlns)
  expect_equivalent(ctl_no_auto$time_vary_auto_generation[1], 1)
  #write MG without autogeneration
  SS_writectl(ctllist = ctl_no_auto,
              verbose = FALSE,
              overwrite = TRUE,
              outfile = file.path(tmp_path, "ctl_no_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_no_auto.ss")))
  unlink(file.path(tmp_path, "ctl_no_auto.ss"))
})

test_that("SS_readctl works for 3.30 files with timevarying SR parameters", {
  tv_folder <- file.path(example_path, "simple_variations", "time_varying")
  dat <- SS_readdat(file.path(tv_folder, "env_link.dat"), verbose = FALSE)
  # short parlines should be autogenerated in MG
  expect_warning(SS_readctl(file.path(tv_folder, "SR_env_block_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat),
                 "There are time varying SR parameters, and AUTOGEN for SR is 0")
  ctl_auto <- suppressWarnings(
    SS_readctl(file.path(tv_folder, "SR_env_block_autogen.ctl"),
               verbose = FALSE, use_datlist = TRUE, datlist = dat)
  )
  # when autogeneration is on, the function should not try to read short parlines.
  expect_null(ctl_auto$SR_parms_tv)
  #write
  SS_writectl(ctllist = ctl_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_auto.ss")))
  unlink(file.path(tmp_path, "ctl_auto.ss"))
  # no autogeneration of short MG par lines selected in ctl
  ctl_no_auto <- SS_readctl(file.path(tv_folder,
                                      "SR_env_block_no_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat)
  ctl_no_auto_ln <- readLines(file.path(tv_folder,
                                        "SR_env_block_no_autogen.ctl"))
  ln1 <- grep("# timevary SR parameters", ctl_no_auto_ln)
  ln2 <- grep("1 #do_recdev:  0=none", ctl_no_auto_ln)
  nlns <- ln2 -ln1 - 1 # no header so only subtract 1
  expect_equal(nrow(ctl_no_auto$SR_parms_tv), nlns)
  expect_equivalent(ctl_no_auto$time_vary_auto_generation[2], 1)
  SS_writectl(ctllist = ctl_no_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_no_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_no_auto.ss")))
  unlink(file.path(tmp_path, "ctl_no_auto.ss"))
})

test_that("SS_readctl works for 3.30 files with timevarying q parameters", {
  tv_folder <- file.path(example_path, "simple_variations", "time_varying")
  dat <- SS_readdat(file.path(tv_folder, "env_link.dat"), verbose = FALSE)
  # short parlines should be autogenerated in q
  expect_warning(SS_readctl(file.path(tv_folder, "q_env_dev_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat),
                 "There are time varying q parameters, and AUTOGEN for")
  ctl_auto <- suppressWarnings(
    SS_readctl(file.path(tv_folder, "q_env_dev_autogen.ctl"),
               verbose = FALSE, use_datlist = TRUE, datlist = dat)
  )
  # when autogeneration is on, the function should not try to read short parlines.
  expect_null(ctl_auto$q_parms_tv)
  #write
  SS_writectl(ctllist = ctl_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_auto.ss")))
  unlink(file.path(tmp_path, "ctl_auto.ss"))
  # no autogeneration of short MG par lines selected in ctl
  ctl_no_auto <- SS_readctl(file.path(tv_folder,
                                      "q_env_dev_no_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat)
  ctl_no_auto_ln <- readLines(file.path(tv_folder,
                                        "q_env_dev_no_autogen.ctl"))
  ln1 <- grep("# timevary Q parameters ", ctl_no_auto_ln)
  ln2 <- grep("# info on dev vectors created for Q parms are ", ctl_no_auto_ln)
  nlns <- ln2 -ln1 - 2 # need to subtract header
  expect_equal(nrow(ctl_no_auto$Q_parms_tv), nlns)
  expect_equivalent(ctl_no_auto$time_vary_auto_generation[3], 1)
  #write
  SS_writectl(ctllist = ctl_no_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_no_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_no_auto.ss")))
  unlink(file.path(tmp_path, "ctl_no_auto.ss"))
})


test_that("SS_readctl works for 3.30 files with timevarying size sel parameters", {
  tv_folder <- file.path(example_path, "simple_variations", "time_varying")
  dat <- SS_readdat(file.path(tv_folder, "env_link.dat"), verbose = FALSE)
  # short parlines should be autogenerated in q
  expect_warning(SS_readctl(file.path(tv_folder, "sel_env_dev_block_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat),
                 "There are time varying")
  ctl_auto <- suppressWarnings(
    SS_readctl(file.path(tv_folder, "sel_env_dev_block_autogen.ctl"),
               verbose = FALSE, use_datlist = TRUE, datlist = dat)
    )
  # when autogeneration is on, the function should not try to read short parlines.
  expect_null(ctl_auto$age_selex_parms_tv)
  expect_null(ctl_auto$size_selex_parms_tv)
  #write
  SS_writectl(ctllist = ctl_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_auto.ss")))
  unlink(file.path(tmp_path, "ctl_auto.ss"))
  # no autogeneration of short MG par lines selected in ctl
  ctl_no_auto <- SS_readctl(file.path(tv_folder,
                                      "sel_env_dev_block_no_autogen.ctl"),
                            verbose = FALSE, use_datlist = TRUE, datlist = dat)
  ctl_no_auto_ln <- readLines(file.path(tv_folder,
                                        "sel_env_dev_block_no_autogen.ctl"))
  ln1 <- grep("# timevary selex parameters ", ctl_no_auto_ln)
  # Note: ln2 works only b/c there are no age time varying sel pars in this case.
  ln2 <- grep("# info on dev vectors created for selex parms ", ctl_no_auto_ln)
  nlns <- ln2 -ln1 - 2 # need to subtract header
  expect_equal(nrow(ctl_no_auto$size_selex_parms_tv), nlns)
  expect_equivalent(ctl_no_auto$time_vary_auto_generation[5], 1)
  #write
  SS_writectl(ctllist = ctl_auto,
              verbose = FALSE,
              outfile = file.path(tmp_path, "ctl_no_auto.ss"))
  expect_true(file.exists(file.path(tmp_path, "ctl_no_auto.ss")))
  unlink(file.path(tmp_path, "ctl_no_auto.ss"))
})

#TODO: develop a test for time varying age selectivity parameters.

# test for selectivity read/write
test_that("SS_readctl works for 3.30 files with diff sel patterns", {
  con_folder <- file.path(example_path, "simple_variations", "selectivity")
  con_files <- list.files(con_folder)
  dat <- SS_readdat(file.path(sim_3.30.13, "simple_data.ss"),
                            verbose = FALSE)
  exists <- suppressWarnings(
              lapply(con_files,
              function(x) {
                ctl <- SS_readctl(file.path(con_folder, x),
                                  verbose = FALSE,
                                  use_datlist = TRUE,
                                  datlist = dat)
          SS_writectl(ctl, file.path(tmp_path, x))
          exists <- file.exists(file.path(tmp_path, x))
        }
  ))

  lapply(exists, function(x) expect_true(x))
  lapply(con_files, function(x) unlink(file.path(tmp_path, x)))
})

test_that("SS_readctl works for 3.30 files F setups", {
  con_folder <- file.path(example_path, "simple_variations", "F")
  con_files <- list.files(con_folder)
  dat <- SS_readdat(file.path(sim_3.30.13, "simple_data.ss"),
                    verbose = FALSE)
  exists <- suppressWarnings(
    lapply(con_files,
           function(x) {
             ctl <- SS_readctl(file.path(con_folder, x),
                               verbose = FALSE,
                               use_datlist = TRUE,
                               datlist = dat)
             SS_writectl(ctl, file.path(tmp_path, x))
             exists <- file.exists(file.path(tmp_path, x))
           }
    ))

  lapply(exists, function(x) expect_true(x))
  lapply(con_files, function(x) unlink(file.path(tmp_path, x)))
})

test_that("SS_readctl works with init_F", {
  con_folder <- file.path(example_path, "simple_variations", "init_F")
  dat <- SS_readdat(file.path(con_folder, "data.ss"), 
                    verbose = FALSE)
  ctl <-SS_readctl(file = file.path(con_folder, "control.ss"), verbose = FALSE,
                   use_datlist = TRUE, datlist = dat)
  SS_writectl(ctl, file.path(tmp_path, "init_F.ctl"), verbose = FALSE)
  expect_true(file.exists(file.path(tmp_path, "init_F.ctl")))
  unlink(file.path(tmp_path, "init_F.ctl"))
})

#clean up
unlink(tmp_path, recursive = TRUE)
